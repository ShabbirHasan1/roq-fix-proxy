/* Copyright (c) 2017-2023, Hans Erik Thrane */

#include "simple/json/session.hpp"

#include <utility>

#include <nlohmann/json.hpp>

#include "roq/exceptions.hpp"
#include "roq/logging.hpp"

#include "roq/web/rest/server_factory.hpp"

using namespace std::literals;

namespace simple {
namespace json {

// === IMPLEMENTATION ===

Session::Session(uint64_t session_id, roq::io::net::tcp::Connection::Factory &factory, Shared &shared)
    : session_id_{session_id}, server_{roq::web::rest::ServerFactory::create(*this, factory)}, shared_{shared} {
}

// web::rest::Server::Handler

void Session::operator()(roq::web::rest::Server::Disconnected const &) {
  shared_.sessions_to_remove.emplace(session_id_);
}

// note!
//   the implementation of roq::web::rest::Server guarantees that you can only
//   send a single response
//   an automatic "not-found" (404) response is generated if not response was
//   generated by this handler
void Session::operator()(roq::web::rest::Server::Request const &request) {
  auto success = false;
  try {
    if (request.headers.connection == roq::web::http::Connection::UPGRADE) {
      roq::log::info("Upgrading session_id={} to websocket..."sv, session_id_);
      (*server_).upgrade(request);
    } else {
      roq::log::info("request={}"sv, request);
      // note!
      //   path is std::span<std::string_view>, i.e. already split
      auto path = request.path;
      // drop prefix?
      if (!std::empty(path) && !std::empty(shared_.settings.json.url_prefix) &&
          path[0] == shared_.settings.json.url_prefix)
        path = path.subspan(1);
      // routes
      if (!std::empty(path)) {
        Response response{*server_, request, shared_.encode_buffer};
        switch (request.method) {
          using enum roq::web::http::Method;
          case GET:
            if (request.path[0] == "exchanges"sv)
              get_exchanges(response, request);
            else if (request.path[0] == "symbols"sv)
              get_symbols(response, request);
            break;
          case HEAD:
            break;
          case POST:
            if (request.path[0] == "order"sv)
              post_order(response, request);
            break;
          case PUT:
            break;
          case DELETE:
            if (request.path[0] == "order"sv)
              delete_order(response, request);
            break;
          case CONNECT:
            break;
          case OPTIONS:
            break;
          case TRACE:
            break;
        }
      }
    }
    success = true;
  } catch (roq::RuntimeError &e) {
    roq::log::error("Error: {}"sv, e);
  } catch (std::exception &e) {
    roq::log::error("Error: {}"sv, e.what());
  }
  if (!success)
    (*server_).close();
}

void Session::operator()(roq::web::rest::Server::Text const &text) {
  roq::log::info(R"(message="{})"sv, text.payload);
  auto success = false;
  try {
    // XXX https://www.jsonrpc.org/specification
    // auto result = process_request(text.payload);
    // (*server_).send_text(result);
    success = true;
  } catch (roq::RuntimeError &e) {
    roq::log::error("Error: {}"sv, e);
  } catch (std::exception &e) {
    roq::log::error("Error: {}"sv, e.what());
  }
  if (!success)
    (*server_).close();
}

void Session::operator()(roq::web::rest::Server::Binary const &) {
  roq::log::warn("Unexpected"sv);
  (*server_).close();
}

// routes

void Session::get_exchanges(Response &response, roq::web::rest::Server::Request const &) {
  response(
      roq::web::http::Status::NOT_FOUND,
      roq::web::http::ContentType::APPLICATION_JSON,
      R"({{"status":"{}"}})"sv,
      "not implemented"sv);
}

void Session::get_symbols(Response &response, roq::web::rest::Server::Request const &) {
  response(
      roq::web::http::Status::NOT_FOUND,
      roq::web::http::ContentType::APPLICATION_JSON,
      R"({{"status":"{}"}})"sv,
      "not implemented"sv);
}

void Session::post_order(Response &response, roq::web::rest::Server::Request const &) {
  response(
      roq::web::http::Status::NOT_FOUND,
      roq::web::http::ContentType::APPLICATION_JSON,
      R"({{"status":"{}"}})"sv,
      "not implemented"sv);
}

void Session::delete_order(Response &response, roq::web::rest::Server::Request const &) {
  response(
      roq::web::http::Status::NOT_FOUND,
      roq::web::http::ContentType::APPLICATION_JSON,
      R"({{"status":"{}"}})"sv,
      "not implemented"sv);
}

}  // namespace json
}  // namespace simple
